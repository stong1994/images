+++

date = 2022-03-10T14:43:00+08:00
title = "go设计之channel"
url = "/internet/go/channel"

toc = true

+++

channel是go中非常具有特色的设计，并且也是新手最难掌握的数据类型。

channel的设计体现出了作者“不要用共享内存来交流，用交流来共享内存（*Do not communicate by sharing memory; instead, share memory by communicating*）”的观点。

## channel的作用

使用channel时需要配合协程，一些协程负责写数据，另外一些协程负责读数据，channel的作用就是将这两部分协程连接起来，可理解为**channel是这些协程和数据的管理者**。

## channel的核心逻辑

### 读和写

作为数据的管理者，channel内部使用**环形队列**来存储数据，关键的数据结构为：**队列**、**读索引**、**写索引**：

- 每写/读入一个数据，写/读索引就往右移动一位，如果索引已经是最后一位，那就移到第一位。
- 如果**写入时队列已满**，那么写数据的协程就进入**等待队列**，等到队列存在空位置时，再唤醒这个协程，写入数据。
- 如果**读取时队列为空**，那么读数据的协程就进入**等待队列**，等到队列中存在数据时，再唤醒这个协程，读取数据。

此时可以看到channel中作为协程的管理者，需要两个等待队列（读和写）来存储这些“需要等待”的协程。

### 关闭channel

日常工作中经常能够用到关闭操作，了解其内部逻辑能够帮助我们更好的使用它。

源码（*runtime/closechan*）逻辑大致如下：

1. 加锁
2. 标识channel已关闭
3. 释放所有正在等待读取的协程（channel已关闭，不再有新数据）
4. 释放所有正在等待写入的协程（这些协程会panic）
5. 释放锁

需要再补充一些逻辑：

1. 读取数据时，如果channel已标识关闭，并且队列为空，那么会标识未接收到数据
2. 读取数据时，即使channel已标识关闭，但如果队列不为空，那么仍会进行读取
3. 写入数据时，如果channel已标识关闭，则会panic

综上可知，关闭channel后：

1. 队列中的数据还是会被消费完
2. 如果再写入数据，会panic
3. 如果再读取数据，会得到零值，第二个返回值为false

实际工程中经常利用第三点，将关闭channel用于通知其他协程。

## 源码中的优化

源码在实现时，对“核心逻辑”进行了一些优化，如：

- 写入数据时先判断是否存在正在等待读的协程，如果存在，直接将数据交给等待读取的协程，而不是先写入队列。因为存在正在等待读的协程，说明队列此时是空的，因此直接将数据交给这个等待读的协程不会影响数据的消费顺序，还能减少一次队列写入和一次队列读取。

## 思考：两个等待队列是否能同时存在

即：一个channel中是否能够同时存在正在等待读的协程和正在等待写的协程？

在上面“源码中的优化”中，我们已知：如果存在正在等待读的协程，那么写入时，会直接将数据交给这个等待读的协程，这样这个写入的协程就不会被放到等待队列中，因此结论是两个等待队列不能同时存在。

## 相关文章

- [Share Memory By Communicating](https://go.dev/blog/codelab-share)
- [一文带你解密 Go 语言之通道 channel](https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651445085&idx=3&sn=2aecb5560dec2c0128ddc7cc3403a5a5&chksm=80bb09afb7cc80b97c989d35c925350121d6164c5dd65eb5bef59aebc811f95614d41c4314fc&scene=21#wechat_redirect)